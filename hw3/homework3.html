<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3" defer></script>
  <script src="./js/rsa.js" defer></script>
  <title>Homework 3 - Distribution</title>
  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="../style.css?v=2">
</head>

<body class="container py-4">
<header class="mb-5 text-center">
  <h1>Homework 3</h1>
  <p class="lead">üß† Decoding RSA Encryption Through Frequency Analysis</p>
</header>
<main>
<article>

<section aria-labelledby="user-interaction">
  <h2 id="user-interaction">üß© User Interaction</h2>
  <p>
  The page displays the encrypted tokens <strong>"Ciphertext"</strong> and a bar chart of their frequency distribution <strong>"Frequency token"</strong>. In the input box labeled <strong>‚ÄúPlaintext Statistical Analysis‚Äù</strong>, you can enter an English text sample.
  The algorithm then calculates the character frequency distribution <strong>"Frequency clear text"</strong> of your sample. By comparing the plaintext character frequencies with the token frequency chart,
  you can attempt to infer the original plaintext using classical frequency-analysis techniques. Use the select controls at the bottom of the page in  the <strong>"Mapping Token to Letter"</strong>
  to manually map each plaintext character to its corresponding encrypted token, refining your decryption attempt.
</p>
<p>
  HINT: Entering a longer English text helps produce a more accurate frequency analysis, giving a better comparison with the encrypted token distribution.
</p>
</section>
<!-- üîπ Testo in chiaro -->
<section class="mt-4">
  <h2>Plaintext Statistical Analysis</h2>
  <textarea id="plainAnalysis" class="form-control" rows="4" placeholder="Scrivi qui del testo in inglese..."></textarea>

  <!-- üîπ Grafici affiancati -->
  <div id="barChartsWrapper" class="d-flex flex-column align-items-center mt-4" style="gap: 40px; display: none;">
    <!-- Istogramma lettere -->
    <div class="bar-chart">
      <h6 class="text-center text-success">Frequency clear text</h6>
      <div id="barChartLetters" class="bars-container"></div>
    </div>

    <!-- Istogramma token -->
    <div class="bar-chart">
      <h6 class="text-center text-primary">Frequency token</h6>
      <div id="barChartTokens" class="bars-container"></div>
    </div>
  </div>
</section>

<!-- üîπ Decodifica -->
<section class="mt-4" id="decodedSection" style="display:none;">
  <h2>üß© Decoding...</h2>
  <div id="decodedText" class="p-3 border rounded"></div>
</section>

<!-- üîπ Cifratura -->
<section class="mt-4" id="chartsSection">
  <div id="cipherBox" class="mt-4" style="display:none;">
    <h2>Ciphertext</h2>
    <div id="cipherOutput" class="p-3 border rounded"></div>
  </div>
</section>

<section id="mappingGridSection" class="mt-5 p-3 border rounded bg-light" style="display:none;">
  <h2>üî† Mapping Token to Letter</h2>
  <div class="mapping-grid mt-3" id="mappingGrid"></div>
  </div>
</section>
<section aria-labelledby="rsa-overview">
  <h2 class="text-center mb-3">üßÆ Algorithm Description</h2>
  <p>
  RSA is a public-key cryptosystem based on two prime numbers. 
  Each character of the message is first converted into a numeric value 
  from <strong>1 to 26</strong> (for example, <strong>A ‚Üí 1</strong>, <strong>B ‚Üí 2</strong>, ‚Ä¶, <strong>Z ‚Üí 26</strong>). 
  This number is then raised to the power of the public exponent <strong>e</strong> 
  and reduced modulo <strong>N</strong>, producing an encrypted token.
  </p>

  <p>
  For instance, if we take <strong>M = 1</strong> for the letter <strong>A</strong> 
  and apply the encryption formula <strong>C = M·µâ mod N</strong>, 
  we obtain a different number <strong>C</strong> representing the ciphertext. 
  Each letter is transformed in this way, resulting in a sequence of encrypted tokens.
  </p>

  <p>
  Security relies on the fact that, while it is easy to compute <strong>C</strong> 
  from <strong>M</strong> using the public key, 
  it is extremely hard to recover <strong>M</strong> from <strong>C</strong> 
  without knowing the private key <strong>d</strong>, 
  since this would require factoring <strong>N</strong> into its prime components.
  </p>
  <ul>
    <li><strong>p</strong> and <strong>q</strong> ‚Äì primes used to compute the modulus <strong>N = p √ó q</strong>, shared by the public and private keys.</li>
    <li><strong>œÜ(N)</strong> ‚Äì Euler‚Äôs totient, calculated as <strong>(p ‚àí 1)(q ‚àí 1)</strong>.</li>
    <li><strong>e</strong> ‚Äì the public exponent, used for encryption.</li>
    <li><strong>d</strong> ‚Äì the private exponent, used for decryption.</li>
  </ul>

  <p>
    Encryption and decryption use modular exponentiation:<strong>C = M^e mod N</strong> and <strong>M = C^d mod N</strong>.
  </p>
  <p>
    The parameter for this exercise are the follow, and each letter of the message is encrypted individually using these parameters:
  </p>
  <p>
  <strong>p</strong> = 13,&nbsp;
  <strong>q</strong> = 17,&nbsp;
  <strong>N</strong> = 221 (<em>N = p √ó q</em>),&nbsp;
  <strong>œÜ(N)</strong> = 192,&nbsp;
  <strong>e</strong> = 11 (public exponent),&nbsp;
  <strong>d</strong> = 35 (private exponent)
  </p>

  <h2>1Ô∏è‚É£ Generating valid numbers</h2>
  <p>
    RSA requires numbers that are coprime with the modulus N.  
    The function below finds all integers smaller than N that share no 
    common divisors with it:
  </p>
  <pre><code>function gcd(a, b) { 
  return b === 0 ? a : gcd(b, a % b); 
}

function coprimi(N) {
  const v = [];
  for (let i = 1; i < N; i++) 
    if (gcd(i, N) === 1) v.push(i);
  return v;
}</code></pre>

  <h2>2Ô∏è‚É£ Mapping letters to numbers</h2>
  <p>
    Each character in the alphabet is associated with one of the coprime numbers.  
    This mapping ensures every letter can be safely encrypted using the RSA formula.
  </p>
  <pre><code>const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ ";
const validNumbers = coprimi(N);
const mapping = {};
for (let i = 0; i < alphabet.length; i++) 
  mapping[alphabet[i]] = validNumbers[i];</code></pre>

  <h2>3Ô∏è‚É£ Modular exponentiation (core of RSA)</h2>
  <p>
    Encryption and decryption are based on modular exponentiation.  
    The function below efficiently computes (base^exp) mod mod using the 
    square-and-multiply algorithm:
  </p>
  <pre><code>function modExp(base, exp, mod) {
  let result = 1n;
  let b = BigInt(base) % BigInt(mod);
  let e = BigInt(exp);
  let m = BigInt(mod);
  while (e > 0n) {
    if (e & 1n) result = (result * b) % m;
    b = (b * b) % m;
    e >>= 1n;
  }
  return Number(result);
}</code></pre>

  <h2>4Ô∏è‚É£ Encrypting the secret text</h2>
  <p>
    Each plaintext letter is converted to a number M and then encrypted with 
    the public exponent e and modulus N using the formula 
    C = M^e mod N.  
    The resulting numbers C are called cipher tokens.
  </p>
  <pre><code>function encryptTextToTokens(text) {
  const tokens = [];
  const upper = text.toUpperCase().trim();
  for (let c of upper) {
    if (mapping[c] !== undefined) {
      const M = mapping[c];
      const C = modExp(M, e, N);
      tokens.push(C);
    }
  }
  return tokens;
}</code></pre>

  <h2>5Ô∏è‚É£ Frequency analysis</h2>
  <p>
    When the user types an English sample in the box, the script counts how often 
    each letter appears and shows a bar chart.  
    By comparing it with the ciphertext token distribution, you can try to guess 
    which tokens represent which letters.
  </p>
  <pre><code>function recalcAllFromPlainAnalysis() {
  const src = plainAnalysis.value || "";
  const text = src.toUpperCase();
  // Count letter frequencies
  const freq = {};
  for (let ch of alphabet) freq[ch] = 0;
  for (let ch of text) if (freq[ch] !== undefined) freq[ch]++;
  updateBarCharts(text);
}</code></pre>

  <h2>6Ô∏è‚É£ Manual token mapping</h2>
  <p>
    The interface lets you manually map tokens to letters.  
    When a mapping is chosen, the program tries to reconstruct the secret message:
  </p>
  <pre><code>function updateDecodedText() {
  const tokenToLetter = {};
  for (const [letter, token] of Object.entries(letterToToken))
    if (token) tokenToLetter[token] = letter;

  const decoded = secretCipherTokens
    .map(t => tokenToLetter[t] || " ")
    .join("");
  decodedText.textContent = decoded;
}</code></pre>

</section>
<!-- ========================================================= -->


<!-- Pulsante back -->
<div class="mt-4 text-center">
  <a href="../index.html" class="btn btn-primary">‚Üê Back to Home</a>
</div>
</main>

<footer class="mt-5 text-center">
  <hr>
  <p><small>&copy; 2025 Francesco ‚Äì Homework 3</small></p>
</footer>
</body>
</html>
